/* Generated by Opal 0.7.0.dev */
(function($opal) {
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $klass = $opal.klass, $hash2 = $opal.hash2, $range = $opal.range;

  $opal.add_stubs(['$nil?', '$==', '$[]', '$source', '$+', '$no', '$compile', '$private', '$!', '$raise', '$new', '$===', '$compile_array', '$compile_hash', '$compile_block', '$compile_call', '$compile_arglist', '$compile_lasgn', '$compile_lvar', '$compile_if', '$compile_dstr', '$compile_iter', '$compile_masgn', '$compile_def', '$compile_yield', '$compile_while', '$compile_attrasgn', '$compile_begin', '$compile_rescue', '$compile_gvar', '$compile_gasgn', '$compile_const', '$compile_sym', '$compile_range', '$compile_for', '$join', '$to_s', '$[]=', '$push', '$each', '$concat', '$each_with_index', '$<', '$-', '$size', '$unique_label', '$map', '$compact', '$_compile_default_params', '$start_with?', '$_compile_resbody', '$s', '$reject']);
  return (function($base, $super) {
    function $AstToBytecodeCompiler(){};
    var self = $AstToBytecodeCompiler = $klass($base, $super, 'AstToBytecodeCompiler', $AstToBytecodeCompiler);

    var def = self._proto, $scope = self._scope;

    def.filename = def.next_unique_label = def.labels_so_far = nil;
    def.$initialize = function() {
      var self = this;

      self.next_unique_label = 0;
      self.filename = nil;
      return self.labels_so_far = $hash2([], {});
    };

    def.$compile_program = function(filename, sexp) {
      var $a, self = this, position = nil;

      self.filename = filename;
      if ((($a = sexp['$nil?']()) !== nil && (!$a._isBoolean || $a == true))) {
        position = []
      } else if (sexp['$[]'](0)['$==']("block")) {
        position = []
      } else if ((($a = sexp.$source()) !== nil && (!$a._isBoolean || $a == true))) {
        position = [["position", self.filename]['$+'](sexp.$source())]
      } else if (sexp['$[]'](0)['$==']("masgn")) {
        position = [["position", self.filename]['$+'](sexp['$[]'](1)['$[]'](1).$source())]
        } else {
        self.$no("top s-exp with nil source")
      };
      return position['$+'](self.$compile(sexp));
    };

    self.$private();

    (function($base, $super) {
      function $AssertionFailed(){};
      var self = $AssertionFailed = $klass($base, $super, 'AssertionFailed', $AssertionFailed);

      var def = self._proto, $scope = self._scope;

      return nil;
    })(self, $scope.RuntimeError);

    (function($base, $super) {
      function $DebuggerDoesntYetSupport(){};
      var self = $DebuggerDoesntYetSupport = $klass($base, $super, 'DebuggerDoesntYetSupport', $DebuggerDoesntYetSupport);

      var def = self._proto, $scope = self._scope;

      return nil;
    })(self, $scope.RuntimeError);

    def.$assert = function(bool) {
      var $a, self = this;

      if ((($a = bool['$!']()) !== nil && (!$a._isBoolean || $a == true))) {
        return self.$raise($scope.AssertionFailed)
        } else {
        return nil
      };
    };

    def.$no = function(feature) {
      var self = this;

      return self.$raise($scope.DebuggerDoesntYetSupport.$new(feature));
    };

    def.$compile = function(sexp) {
      var $a, self = this, $case = nil;

      if ((($a = sexp['$nil?']()) !== nil && (!$a._isBoolean || $a == true))) {
        return [["result_nil"]]};
      return (function() {$case = sexp['$[]'](0);if ("int"['$===']($case)) {return [["token"]['$+'](sexp.$source()), ["result", sexp['$[]'](1)]]}else if ("float"['$===']($case)) {return [["token"]['$+'](sexp.$source()), ["result", sexp['$[]'](1)]]}else if ("str"['$===']($case)) {if ((($a = sexp.$source()) !== nil && (!$a._isBoolean || $a == true))) {
        return [["token"]['$+'](sexp.$source()), ["result", sexp['$[]'](1)]]
        } else {
        return [["result", sexp['$[]'](1)]]
      }}else if ("nil"['$===']($case)) {if ((($a = sexp.$source()) !== nil && (!$a._isBoolean || $a == true))) {
        return [["token"]['$+'](sexp.$source()), ["result_nil"]]
        } else {
        return [["result_nil"]]
      }}else if ("true"['$===']($case)) {return [["token"]['$+'](sexp.$source()), ["result", true]]}else if ("false"['$===']($case)) {return [["token"]['$+'](sexp.$source()), ["result", false]]}else if ("array"['$===']($case)) {return self.$compile_array(sexp)}else if ("hash"['$===']($case)) {return self.$compile_hash(sexp)}else if ("block"['$===']($case)) {return self.$compile_block(sexp)}else if ("call"['$===']($case)) {return self.$compile_call(sexp)}else if ("arglist"['$===']($case)) {return self.$compile_arglist(sexp)}else if ("paren"['$===']($case)) {return self.$compile(sexp['$[]'](1))}else if ("lasgn"['$===']($case)) {return self.$compile_lasgn(sexp)}else if ("lvar"['$===']($case)) {return self.$compile_lvar(sexp)}else if ("if"['$===']($case)) {return self.$compile_if(sexp)}else if ("dstr"['$===']($case)) {return self.$compile_dstr(sexp)}else if ("evstr"['$===']($case)) {return self.$compile(sexp['$[]'](1))}else if ("iter"['$===']($case)) {return self.$compile_iter(sexp)}else if ("masgn"['$===']($case)) {return self.$compile_masgn(sexp)}else if ("def"['$===']($case)) {return self.$compile_def(sexp)}else if ("yield"['$===']($case)) {return self.$compile_yield(sexp)}else if ("while"['$===']($case)) {return self.$compile_while(sexp)}else if ("attrasgn"['$===']($case)) {return self.$compile_attrasgn(sexp)}else if ("begin"['$===']($case)) {return self.$compile_begin(sexp)}else if ("rescue"['$===']($case)) {return self.$compile_rescue(sexp)}else if ("gvar"['$===']($case)) {return self.$compile_gvar(sexp)}else if ("gasgn"['$===']($case)) {return self.$compile_gasgn(sexp)}else if ("const"['$===']($case)) {return self.$compile_const(sexp)}else if ("sym"['$===']($case)) {return self.$compile_sym(sexp)}else if ("irange"['$===']($case)) {return self.$compile_range(sexp, false)}else if ("erange"['$===']($case)) {return self.$compile_range(sexp, true)}else if ("for"['$===']($case)) {return self.$compile_for(sexp)}else {return self.$no((("s-exp with head ") + (sexp['$[]'](0)))['$+'](((function() {if ((($a = sexp.$source()) !== nil && (!$a._isBoolean || $a == true))) {
        return " on line " + (sexp.$source()['$[]'](0))
        } else {
        return ""
      }; return nil; })())))}})();
    };

    def.$source = function(statement) {
      var self = this;

      if (statement['$[]'](0)['$==']("block")) {
        return statement['$[]'](1).$source()
      } else if (statement['$[]'](0)['$==']("masgn")) {
        return statement['$[]'](1)['$[]'](1).$source()
        } else {
        return statement.$source()
      };
    };

    def.$unique_label = function(name1, sexp_for_source, name2) {
      var $a, $b, $c, self = this, label = nil;

      if (name2 == null) {
        name2 = nil
      }
      label = "" + (name1) + "_" + (self.filename) + "_";
      if ((($a = ($b = (($c = sexp_for_source !== false && sexp_for_source !== nil) ? self.$source(sexp_for_source) : $c), $b !== false && $b !== nil ?self.$source(sexp_for_source)['$==']([-1, -1])['$!']() : $b)) !== nil && (!$a._isBoolean || $a == true))) {
        label = label['$+'](self.$source(sexp_for_source).$join("_"))
        } else {
        label = label['$+']((self.next_unique_label = self.next_unique_label['$+'](1)).$to_s())
      };
      if (name2 !== false && name2 !== nil) {
        label = label['$+']("_" + (name2))};
      if ((($a = self.labels_so_far['$[]'](label)) !== nil && (!$a._isBoolean || $a == true))) {
        self.$raise("Non-unique label " + (label))};
      self.labels_so_far['$[]='](label, true);
      return label;
    };

    def.$compile_array = function(sexp) {
      var $a, $b, TMP_1, self = this, _ = nil, elements = nil, bytecodes = nil;

      $a = $opal.to_ary(sexp), _ = ($a[0] == null ? nil : $a[0]), elements = $slice.call($a, 1);
      bytecodes = [];
      bytecodes.$push(["start_call"]);
      bytecodes.$push(["result_array"]);
      bytecodes.$push(["arg"]);
      bytecodes.$push(["result", "push"]);
      bytecodes.$push(["make_symbol"]);
      bytecodes.$push(["arg"]);
      bytecodes.$push(["result_nil"]);
      bytecodes.$push(["arg"]);
      ($a = ($b = elements).$each, $a._p = (TMP_1 = function(element){var self = TMP_1._s || this;
if (element == null) element = nil;
      bytecodes.$concat(self.$compile(element));
        return bytecodes.$push(["arg"]);}, TMP_1._s = self, TMP_1), $a).call($b);
      bytecodes.$push(["pre_call"]);
      bytecodes.$push(["call"]);
      return bytecodes;
    };

    def.$compile_hash = function(sexp) {
      var $a, $b, TMP_2, self = this, _ = nil, elements = nil, bytecodes = nil;

      $a = $opal.to_ary(sexp), _ = ($a[0] == null ? nil : $a[0]), elements = $slice.call($a, 1);
      bytecodes = [];
      bytecodes.$push(["start_call"]);
      bytecodes.$push(["const", "Hash"]);
      bytecodes.$push(["arg"]);
      bytecodes.$push(["result", "[]"]);
      bytecodes.$push(["make_symbol"]);
      bytecodes.$push(["arg"]);
      bytecodes.$push(["result_nil"]);
      bytecodes.$push(["arg"]);
      ($a = ($b = elements).$each, $a._p = (TMP_2 = function(element){var self = TMP_2._s || this;
if (element == null) element = nil;
      bytecodes.$concat(self.$compile(element));
        return bytecodes.$push(["arg"]);}, TMP_2._s = self, TMP_2), $a).call($b);
      bytecodes.$push(["pre_call"]);
      bytecodes.$push(["call"]);
      return bytecodes;
    };

    def.$compile_block = function(sexp) {
      var $a, $b, TMP_3, self = this, _ = nil, statements = nil, bytecodes = nil;

      $a = $opal.to_ary(sexp), _ = ($a[0] == null ? nil : $a[0]), statements = $slice.call($a, 1);
      bytecodes = [];
      ($a = ($b = statements).$each_with_index, $a._p = (TMP_3 = function(statement, i){var self = TMP_3._s || this, $a;
        if (self.filename == null) self.filename = nil;
if (statement == null) statement = nil;if (i == null) i = nil;
      if ((($a = self.$source(statement)) !== nil && (!$a._isBoolean || $a == true))) {
          bytecodes.$push(["position", self.filename]['$+'](self.$source(statement)))};
        bytecodes.$concat(self.$compile(statement));
        if (i['$<'](statements.$size()['$-'](1))) {
          return bytecodes.$push(["discard"])
          } else {
          return nil
        };}, TMP_3._s = self, TMP_3), $a).call($b);
      return bytecodes;
    };

    def.$compile_call = function(sexp) {
      var $a, self = this, _ = nil, receiver = nil, method_name = nil, arglist = nil, optional_iter = nil, bytecodes = nil, label_after_return = nil, start_label = nil;

      $a = $opal.to_ary(sexp), _ = ($a[0] == null ? nil : $a[0]), receiver = ($a[1] == null ? nil : $a[1]), method_name = ($a[2] == null ? nil : $a[2]), arglist = ($a[3] == null ? nil : $a[3]), optional_iter = ($a[4] == null ? nil : $a[4]);
      bytecodes = [];
      bytecodes.$push(["start_call"]);
      if (receiver !== false && receiver !== nil) {
        bytecodes.$concat(self.$compile(receiver))
        } else {
        bytecodes.$push(["top"])
      };
      bytecodes.$push(["arg"]);
      bytecodes.$push(["token"]['$+'](sexp.$source()));
      bytecodes.$push(["result", method_name.$to_s()]);
      bytecodes.$push(["make_symbol"]);
      bytecodes.$push(["arg"]);
      if (optional_iter !== false && optional_iter !== nil) {
        label_after_return = self.$unique_label("after_return", optional_iter['$[]'](2));
        bytecodes.$push(["goto", label_after_return]);
        start_label = self.$unique_label("start", optional_iter['$[]'](2));
        bytecodes.$push(["label", start_label]);
        bytecodes.$concat(self.$compile(optional_iter));
        bytecodes.$push(["label", label_after_return]);
        bytecodes.$push(["make_proc", start_label]);
        } else {
        bytecodes.$push(["result_nil"])
      };
      bytecodes.$push(["arg"]);
      bytecodes.$concat(self.$compile(arglist));
      bytecodes.$push(["pre_call"]);
      bytecodes.$push(["call"]);
      return bytecodes;
    };

    def.$compile_arglist = function(sexp) {
      var $a, $b, TMP_4, self = this, _ = nil, args = nil, bytecodes = nil;

      $a = $opal.to_ary(sexp), _ = ($a[0] == null ? nil : $a[0]), args = $slice.call($a, 1);
      bytecodes = [];
      ($a = ($b = args).$each, $a._p = (TMP_4 = function(arg){var self = TMP_4._s || this;
if (arg == null) arg = nil;
      bytecodes.$concat(self.$compile(arg));
        return bytecodes.$push(["arg"]);}, TMP_4._s = self, TMP_4), $a).call($b);
      return bytecodes;
    };

    def.$compile_lasgn = function(sexp) {
      var $a, self = this, _ = nil, var_name = nil, expression = nil, bytecodes = nil;

      $a = $opal.to_ary(sexp), _ = ($a[0] == null ? nil : $a[0]), var_name = ($a[1] == null ? nil : $a[1]), expression = ($a[2] == null ? nil : $a[2]);
      bytecodes = [];
      bytecodes.$push(["token"]['$+'](sexp.$source()));
      bytecodes.$push(["start_vars", var_name.$to_s()]);
      bytecodes.$concat(self.$compile(expression));
      bytecodes.$push(["to_var", var_name.$to_s()]);
      return bytecodes;
    };

    def.$compile_lvar = function(sexp) {
      var $a, self = this, _ = nil, var_name = nil;

      $a = $opal.to_ary(sexp), _ = ($a[0] == null ? nil : $a[0]), var_name = ($a[1] == null ? nil : $a[1]);
      return [["token"]['$+'](sexp.$source()), ["from_var", var_name.$to_s()]];
    };

    def.$compile_if = function(sexp) {
      var $a, $b, self = this, _ = nil, condition = nil, then_block = nil, else_block = nil, bytecodes = nil, label_else = nil, label_endif = nil;

      $a = $opal.to_ary(sexp), _ = ($a[0] == null ? nil : $a[0]), condition = ($a[1] == null ? nil : $a[1]), then_block = ($a[2] == null ? nil : $a[2]), else_block = ($a[3] == null ? nil : $a[3]);
      bytecodes = [];
      bytecodes.$concat(self.$compile(condition));
      label_else = self.$unique_label("else", sexp);
      label_endif = self.$unique_label("endif", sexp);
      bytecodes.$push(["goto_if_not", label_else]);
      if ((($a = (($b = then_block !== false && then_block !== nil) ? then_block.$source() : $b)) !== nil && (!$a._isBoolean || $a == true))) {
        bytecodes.$push(["position", self.filename]['$+'](then_block.$source()))};
      bytecodes.$concat(self.$compile(then_block));
      bytecodes.$push(["goto", label_endif]);
      bytecodes.$push(["label", label_else]);
      if ((($a = (($b = else_block !== false && else_block !== nil) ? else_block.$source() : $b)) !== nil && (!$a._isBoolean || $a == true))) {
        bytecodes.$push(["position", self.filename]['$+'](else_block.$source()))};
      bytecodes.$concat(self.$compile(else_block));
      bytecodes.$push(["label", label_endif]);
      return bytecodes;
    };

    def.$compile_dstr = function(sexp) {
      var $a, $b, TMP_5, self = this, _ = nil, str = nil, strs_or_evstrs = nil, bytecodes = nil;

      $a = $opal.to_ary(sexp), _ = ($a[0] == null ? nil : $a[0]), str = ($a[1] == null ? nil : $a[1]), strs_or_evstrs = $slice.call($a, 2);
      bytecodes = [];
      bytecodes.$push(["start_call"]);
      bytecodes.$push(["result", str]);
      bytecodes.$push(["arg"]);
      bytecodes.$push(["result", "append"]);
      bytecodes.$push(["make_symbol"]);
      bytecodes.$push(["arg"]);
      bytecodes.$push(["result_nil"]);
      bytecodes.$push(["arg"]);
      ($a = ($b = strs_or_evstrs).$each, $a._p = (TMP_5 = function(str_or_evstr){var self = TMP_5._s || this;
if (str_or_evstr == null) str_or_evstr = nil;
      bytecodes.$concat(self.$compile(str_or_evstr));
        return bytecodes.$push(["arg"]);}, TMP_5._s = self, TMP_5), $a).call($b);
      bytecodes.$push(["pre_call"]);
      bytecodes.$push(["call"]);
      return bytecodes;
    };

    def.$compile_iter = function(sexp) {
      var $a, $b, TMP_6, $c, $d, self = this, _ = nil, assignments = nil, statement = nil, bytecodes = nil, splat_num = nil, block_num = nil, optional_block = nil, min_num_args = nil, max_num_args = nil, var_names = nil, i = nil;

      $a = $opal.to_ary(sexp), _ = ($a[0] == null ? nil : $a[0]), assignments = ($a[1] == null ? nil : $a[1]), statement = ($a[2] == null ? nil : $a[2]);
      bytecodes = [];
      splat_num = -1;
      block_num = -1;
      optional_block = nil;
      min_num_args = max_num_args = 0;
      if ((($a = assignments['$nil?']()) !== nil && (!$a._isBoolean || $a == true))) {
        var_names = []
      } else if (assignments['$[]'](0)['$==']("lasgn")) {
        min_num_args = max_num_args = 1;
        var_names = [assignments['$[]'](1).$to_s()];
      } else if (assignments['$[]'](0)['$==']("masgn")) {
        if (assignments['$[]'](1)['$[]'](0)['$==']("array")) {
          i = -1;
          var_names = ($a = ($b = assignments['$[]'](1)['$[]']($range(1, -1, false))).$map, $a._p = (TMP_6 = function(part){var self = TMP_6._s || this, $a, $b;
if (part == null) part = nil;
          i = i['$+'](1);
            if (part['$[]'](0)['$==']("lasgn")) {
              min_num_args = min_num_args['$+'](1);
              max_num_args = max_num_args['$+'](1);
              return part['$[]'](1).$to_s();
            } else if ((($a = (($b = part['$[]'](0)['$==']("splat")) ? part['$[]'](1)['$[]'](0)['$==']("lasgn") : $b)) !== nil && (!$a._isBoolean || $a == true))) {
              max_num_args = nil;
              splat_num = i;
              return part['$[]'](1)['$[]'](1).$to_s();
            } else if ((($a = (($b = part['$[]'](0)['$==']("block_pass")) ? part['$[]'](1)['$[]'](0)['$==']("lasgn") : $b)) !== nil && (!$a._isBoolean || $a == true))) {
              block_num = i;
              return part['$[]'](1)['$[]'](1).$to_s();
            } else if (part['$[]'](0)['$==']("block")) {
              min_num_args = min_num_args['$-']((part.$size()['$-'](1)));
              optional_block = part;
              return nil;
              } else {
              return self.$no("contents of :masgn's :array except "['$+'](" :lasgn, :splat :lasgn, :block_pass :lasgn, or :block"))
            };}, TMP_6._s = self, TMP_6), $a).call($b);
          var_names = var_names.$compact();
          } else {
          self.$no("contents of :masgn besides :array")
        }
        } else {
        self.$no("assignments other than :lasgn and :masgn")
      };
      bytecodes.$push(["args", min_num_args, max_num_args]['$+'](var_names));
      bytecodes.$push(["to_vars", splat_num, block_num]['$+'](var_names));
      bytecodes.$push(["discard"]);
      if (optional_block !== false && optional_block !== nil) {
        bytecodes.$concat(self.$_compile_default_params(optional_block, var_names, statement))};
      if ((($a = ($c = (($d = statement !== false && statement !== nil) ? self.$source(statement) : $d), $c !== false && $c !== nil ?statement['$[]'](0)['$==']("block")['$!']() : $c)) !== nil && (!$a._isBoolean || $a == true))) {
        bytecodes.$push(["position", self.filename]['$+'](self.$source(statement)))};
      bytecodes.$concat(self.$compile(statement));
      bytecodes.$push(["return"]);
      return bytecodes;
    };

    def.$compile_masgn = function(sexp) {
      var $a, $b, TMP_7, self = this, _ = nil, to_array = nil, from_expression = nil, bytecodes = nil, splat_num = nil, i = nil, var_names = nil;

      $a = $opal.to_ary(sexp), _ = ($a[0] == null ? nil : $a[0]), to_array = ($a[1] == null ? nil : $a[1]), from_expression = ($a[2] == null ? nil : $a[2]);
      bytecodes = [];
      splat_num = -1;
      if (to_array['$[]'](0)['$==']("array")) {
        i = -1;
        var_names = ($a = ($b = to_array['$[]']($range(1, -1, false))).$map, $a._p = (TMP_7 = function(lasgn){var self = TMP_7._s || this, $a, $b;
if (lasgn == null) lasgn = nil;
        i = i['$+'](1);
          if (lasgn['$[]'](0)['$==']("lasgn")) {
            bytecodes.$push(["token"]['$+'](lasgn.$source()));
            bytecodes.$push(["start_vars", lasgn['$[]'](1).$to_s()]);
            return lasgn['$[]'](1).$to_s();
          } else if ((($a = (($b = lasgn['$[]'](0)['$==']("splat")) ? lasgn['$[]'](1)['$[]'](0)['$==']("lasgn") : $b)) !== nil && (!$a._isBoolean || $a == true))) {
            bytecodes.$push(["token"]['$+'](lasgn['$[]'](1).$source()));
            bytecodes.$push(["start_vars", lasgn['$[]'](1)['$[]'](1).$to_s()]);
            splat_num = i;
            return lasgn['$[]'](1)['$[]'](1).$to_s();
            } else {
            return self.$no("contents of :masgn's :array except :lasgn or :splat :lasgn")
          };}, TMP_7._s = self, TMP_7), $a).call($b);
      } else if ((($a = to_array['$[]'](0)['$==']("array")['$!']()) !== nil && (!$a._isBoolean || $a == true))) {
        self.$no("masgn[1] except array")};
      bytecodes.$concat(self.$compile(from_expression));
      bytecodes.$push(["to_vars", splat_num, -1]['$+'](var_names));
      return bytecodes;
    };

    def.$compile_def = function(sexp) {
      var $a, $b, TMP_8, self = this, _ = nil, object = nil, method_name = nil, args = nil, block = nil, bytecodes = nil, label_after_return = nil, start_label = nil, i = nil, splat_num = nil, block_num = nil, min_num_args = nil, max_num_args = nil, optional_block = nil, var_names = nil;

      $a = $opal.to_ary(sexp), _ = ($a[0] == null ? nil : $a[0]), object = ($a[1] == null ? nil : $a[1]), method_name = ($a[2] == null ? nil : $a[2]), args = ($a[3] == null ? nil : $a[3]), block = ($a[4] == null ? nil : $a[4]);
      bytecodes = [];
      bytecodes.$push(["token"]['$+'](sexp.$source()));
      label_after_return = self.$unique_label("after_return", sexp);
      bytecodes.$push(["goto", label_after_return]);
      start_label = self.$unique_label("start", sexp);
      bytecodes.$push(["label", start_label]);
      i = -1;
      splat_num = -1;
      block_num = -1;
      min_num_args = 0;
      max_num_args = 0;
      optional_block = nil;
      var_names = [];
      ($a = ($b = args['$[]']($range(1, -1, false))).$each, $a._p = (TMP_8 = function(part){var self = TMP_8._s || this, $a;
if (part == null) part = nil;
      i = i['$+'](1);
        if (part['$[]'](0)['$==']("block")) {
          min_num_args = min_num_args['$-']((part.$size()['$-'](1)));
          return optional_block = part;
        } else if ((($a = part.$to_s()['$start_with?']("*")) !== nil && (!$a._isBoolean || $a == true))) {
          splat_num = i;
          max_num_args = nil;
          return var_names.$push(part['$[]']($range(1, -1, false)).$to_s());
        } else if ((($a = part.$to_s()['$start_with?']("&")) !== nil && (!$a._isBoolean || $a == true))) {
          block_num = i;
          return var_names.$push(part['$[]']($range(1, -1, false)).$to_s());
          } else {
          min_num_args = min_num_args['$+'](1);
          max_num_args = max_num_args['$+'](1);
          return var_names.$push(part.$to_s());
        };}, TMP_8._s = self, TMP_8), $a).call($b);
      bytecodes.$push(["args", min_num_args, max_num_args]['$+'](var_names));
      bytecodes.$push(["to_vars", splat_num, block_num]['$+'](var_names));
      bytecodes.$push(["discard"]);
      if (optional_block !== false && optional_block !== nil) {
        bytecodes.$concat(self.$_compile_default_params(optional_block, var_names, sexp))};
      bytecodes.$concat(self.$compile(block));
      bytecodes.$push(["return"]);
      bytecodes.$push(["label", label_after_return]);
      bytecodes.$push(["start_call"]);
      if (object !== false && object !== nil) {
        bytecodes.$concat(self.$compile(object))
        } else {
        bytecodes.$push(["top"])
      };
      bytecodes.$push(["arg"]);
      bytecodes.$push(["result", "define_method"]);
      bytecodes.$push(["make_symbol"]);
      bytecodes.$push(["arg"]);
      bytecodes.$push(["make_proc", start_label]);
      bytecodes.$push(["arg"]);
      bytecodes.$push(["result", method_name.$to_s()]);
      bytecodes.$push(["make_symbol"]);
      bytecodes.$push(["arg"]);
      bytecodes.$push(["pre_call"]);
      bytecodes.$push(["call"]);
      return bytecodes;
    };

    def.$_compile_default_params = function(defaulting_block, var_names, sexp) {
      var $a, $b, TMP_9, $c, TMP_10, self = this, bytecodes = nil, labels = nil;

      bytecodes = [];
      labels = ($a = ($b = ($range(0, var_names.$size(), false))).$map, $a._p = (TMP_9 = function(i){var self = TMP_9._s || this;
if (i == null) i = nil;
      return self.$unique_label("param_defaults", sexp, i)}, TMP_9._s = self, TMP_9), $a).call($b);
      bytecodes.$push(["goto_param_defaults"]['$+'](labels));
      ($a = ($c = labels).$each_with_index, $a._p = (TMP_10 = function(label, i){var self = TMP_10._s || this;
if (label == null) label = nil;if (i == null) i = nil;
      bytecodes.$push(["label", label]);
        if (i['$<'](labels.$size()['$-'](1))) {
          bytecodes.$concat(self.$compile(defaulting_block['$[]'](i['$+'](1))));
          return bytecodes.$push(["discard"]);
          } else {
          return nil
        };}, TMP_10._s = self, TMP_10), $a).call($c);
      return bytecodes;
    };

    def.$compile_yield = function(sexp) {
      var $a, $b, TMP_11, self = this, _ = nil, args = nil, bytecodes = nil;

      $a = $opal.to_ary(sexp), _ = ($a[0] == null ? nil : $a[0]), args = $slice.call($a, 1);
      bytecodes = [];
      bytecodes.$push(["token"]['$+'](sexp.$source()));
      bytecodes.$push(["start_call"]);
      bytecodes.$push(["from_var", "__unnamed_block"]);
      bytecodes.$push(["arg"]);
      bytecodes.$push(["result", "call"]);
      bytecodes.$push(["make_symbol"]);
      bytecodes.$push(["arg"]);
      bytecodes.$push(["result_nil"]);
      bytecodes.$push(["arg"]);
      ($a = ($b = args).$each, $a._p = (TMP_11 = function(arg){var self = TMP_11._s || this;
if (arg == null) arg = nil;
      bytecodes.$concat(self.$compile(arg));
        return bytecodes.$push(["arg"]);}, TMP_11._s = self, TMP_11), $a).call($b);
      bytecodes.$push(["pre_call"]);
      bytecodes.$push(["call"]);
      return bytecodes;
    };

    def.$compile_while = function(sexp) {
      var $a, self = this, _ = nil, condition = nil, block = nil, bytecodes = nil, label_start = nil, label_end = nil;

      $a = $opal.to_ary(sexp), _ = ($a[0] == null ? nil : $a[0]), condition = ($a[1] == null ? nil : $a[1]), block = ($a[2] == null ? nil : $a[2]);
      bytecodes = [];
      if (sexp.$source()['$=='](nil)) {
        self.$raise("Error: running an uncustomized version of Opal.  "['$+']("Try with bundle exec instead."))};
      bytecodes.$push(["token"]['$+'](sexp.$source()));
      label_start = self.$unique_label("start", condition);
      label_end = self.$unique_label("end", condition);
      bytecodes.$push(["label", label_start]);
      bytecodes.$concat(self.$compile(condition));
      bytecodes.$push(["goto_if_not", label_end]);
      bytecodes.$concat(self.$compile(block));
      bytecodes.$push(["discard"]);
      bytecodes.$push(["goto", label_start]);
      bytecodes.$push(["label", label_end]);
      bytecodes.$push(["result_nil"]);
      return bytecodes;
    };

    def.$compile_attrasgn = function(sexp) {
      var $a, self = this, _ = nil, receiver = nil, method_name = nil, arglist = nil, bytecodes = nil;

      $a = $opal.to_ary(sexp), _ = ($a[0] == null ? nil : $a[0]), receiver = ($a[1] == null ? nil : $a[1]), method_name = ($a[2] == null ? nil : $a[2]), arglist = ($a[3] == null ? nil : $a[3]);
      bytecodes = [];
      bytecodes.$push(["start_call"]);
      bytecodes.$concat(self.$compile(receiver));
      bytecodes.$push(["arg"]);
      bytecodes.$push(["result", method_name]);
      bytecodes.$push(["make_symbol"]);
      bytecodes.$push(["arg"]);
      bytecodes.$push(["result_nil"]);
      bytecodes.$push(["arg"]);
      bytecodes.$concat(self.$compile(arglist));
      bytecodes.$push(["pre_call"]);
      bytecodes.$push(["call"]);
      return bytecodes;
    };

    def.$compile_begin = function(sexp) {
      var self = this;

      if (sexp.$size()['$=='](2)) {
        } else {
        self.$raise()
      };
      return self.$compile(sexp['$[]'](1));
    };

    def.$compile_rescue = function(sexp) {
      var $a, $b, $c, TMP_12, self = this, _ = nil, body = nil, resbodies = nil, bytecodes = nil, label_rescue = nil, label_end = nil;

      $a = $opal.to_ary(sexp), _ = ($a[0] == null ? nil : $a[0]), body = ($a[1] == null ? nil : $a[1]), resbodies = $slice.call($a, 2);
      bytecodes = [];
      label_rescue = self.$unique_label("rescue", resbodies['$[]'](0));
      bytecodes.$push(["push_rescue", label_rescue]);
      if ((($a = ((($b = body['$nil?']()) !== false && $b !== nil) ? $b : ((($c = body['$[]'](0)['$==']("block")) ? body.$size()['$=='](1) : $c)))) !== nil && (!$a._isBoolean || $a == true))) {
        bytecodes.$push(["result_nil"])
        } else {
        bytecodes.$concat(self.$compile(body))
      };
      label_end = self.$unique_label("end_rescue", resbodies['$[]'](0));
      bytecodes.$push(["pop_rescue", label_rescue]);
      bytecodes.$push(["goto", label_end]);
      bytecodes.$push(["label", label_rescue]);
      bytecodes.$push(["discard"]);
      ($a = ($b = resbodies).$each, $a._p = (TMP_12 = function(resbody){var self = TMP_12._s || this;
if (resbody == null) resbody = nil;
      return bytecodes.$concat(self.$_compile_resbody(resbody, label_end))}, TMP_12._s = self, TMP_12), $a).call($b);
      bytecodes.$push(["start_call"]);
      bytecodes.$push(["top"]);
      bytecodes.$push(["arg"]);
      bytecodes.$push(["result", "raise"]);
      bytecodes.$push(["make_symbol"]);
      bytecodes.$push(["arg"]);
      bytecodes.$push(["result_nil"]);
      bytecodes.$push(["arg"]);
      bytecodes.$push(["pre_call"]);
      bytecodes.$push(["call"]);
      bytecodes.$push(["label", label_end]);
      bytecodes.$push(["clear_dollar_bang"]);
      return bytecodes;
    };

    def.$_compile_resbody = function(sexp, label_end) {
      var $a, self = this, _ = nil, array = nil, body = nil, klass = nil, lasgn = nil, bytecodes = nil, label_endif = nil;

      $a = $opal.to_ary(sexp), _ = ($a[0] == null ? nil : $a[0]), array = ($a[1] == null ? nil : $a[1]), body = ($a[2] == null ? nil : $a[2]);
      $a = $opal.to_ary(array), _ = ($a[0] == null ? nil : $a[0]), klass = ($a[1] == null ? nil : $a[1]), lasgn = ($a[2] == null ? nil : $a[2]);
      bytecodes = [];
      if (klass !== false && klass !== nil) {
        bytecodes.$push(["start_call"]);
        bytecodes.$concat(self.$compile(klass));
        bytecodes.$push(["arg"]);
        bytecodes.$push(["result", "==="]);
        bytecodes.$push(["make_symbol"]);
        bytecodes.$push(["arg"]);
        bytecodes.$push(["result_nil"]);
        bytecodes.$push(["arg"]);
        bytecodes.$push(["from_gvar", "$!"]);
        bytecodes.$push(["arg"]);
        bytecodes.$push(["pre_call"]);
        bytecodes.$push(["call"]);
        } else {
        bytecodes.$push(["result", true])
      };
      label_endif = self.$unique_label("endif", sexp);
      bytecodes.$push(["goto_if_not", label_endif]);
      if (lasgn !== false && lasgn !== nil) {
        bytecodes.$concat(self.$compile(lasgn));
        bytecodes.$push(["discard"]);};
      if (body !== false && body !== nil) {
        bytecodes.$concat(self.$compile(body))
        } else {
        bytecodes.$push(["result_nil"])
      };
      bytecodes.$push(["goto", label_end]);
      bytecodes.$push(["label", label_endif]);
      return bytecodes;
    };

    def.$compile_gvar = function(sexp) {
      var $a, self = this, _ = nil, var_name = nil;

      $a = $opal.to_ary(sexp), _ = ($a[0] == null ? nil : $a[0]), var_name = ($a[1] == null ? nil : $a[1]);
      if ((($a = sexp.$source()) !== nil && (!$a._isBoolean || $a == true))) {
        return [["token"]['$+'](sexp.$source()), ["from_gvar", var_name.$to_s()]]
        } else {
        return [["from_gvar", var_name.$to_s()]]
      };
    };

    def.$compile_gasgn = function(sexp) {
      var $a, self = this, _ = nil, var_name = nil, expression = nil, bytecodes = nil;

      $a = $opal.to_ary(sexp), _ = ($a[0] == null ? nil : $a[0]), var_name = ($a[1] == null ? nil : $a[1]), expression = ($a[2] == null ? nil : $a[2]);
      bytecodes = [];
      bytecodes.$push(["token"]['$+'](sexp.$source()));
      bytecodes.$concat(self.$compile(expression));
      bytecodes.$push(["to_gvar", var_name.$to_s()]);
      return bytecodes;
    };

    def.$compile_const = function(sexp) {
      var $a, self = this, _ = nil, const_name = nil;

      $a = $opal.to_ary(sexp), _ = ($a[0] == null ? nil : $a[0]), const_name = ($a[1] == null ? nil : $a[1]);
      if ((($a = sexp.$source()) !== nil && (!$a._isBoolean || $a == true))) {
        return [["token"]['$+'](sexp.$source()), ["const", const_name.$to_s()]]
        } else {
        return [["const", const_name.$to_s()]]
      };
    };

    def.$compile_sym = function(sexp) {
      var $a, self = this, _ = nil, string = nil;

      $a = $opal.to_ary(sexp), _ = ($a[0] == null ? nil : $a[0]), string = ($a[1] == null ? nil : $a[1]);
      if ((($a = sexp.$source()) !== nil && (!$a._isBoolean || $a == true))) {
        return [["token"]['$+'](sexp.$source()), ["result", string.$to_s()], ["make_symbol"]]
        } else {
        return [["result", string.$to_s()], ["make_symbol"]]
      };
    };

    def.$compile_range = function(sexp, exclusive) {
      var $a, self = this, _ = nil, from = nil, to = nil, bytecodes = nil;

      $a = $opal.to_ary(sexp), _ = ($a[0] == null ? nil : $a[0]), from = ($a[1] == null ? nil : $a[1]), to = ($a[2] == null ? nil : $a[2]);
      bytecodes = [];
      bytecodes.$push(["start_call"]);
      bytecodes.$push(["const", "Range"]);
      bytecodes.$push(["arg"]);
      bytecodes.$push(["result", "new"]);
      bytecodes.$push(["make_symbol"]);
      bytecodes.$push(["arg"]);
      bytecodes.$push(["result_nil"]);
      bytecodes.$push(["arg"]);
      bytecodes.$concat(self.$compile(from));
      bytecodes.$push(["arg"]);
      bytecodes.$concat(self.$compile(to));
      bytecodes.$push(["arg"]);
      bytecodes.$push(["result", exclusive]);
      bytecodes.$push(["arg"]);
      bytecodes.$push(["pre_call"]);
      bytecodes.$push(["call"]);
      return bytecodes;
    };

    def.$compile_for = function(sexp) {
      var $a, $b, TMP_13, $c, self = this, _ = nil, array = nil, lasgn_or_array = nil, body = nil, e_dot_next = nil, assigns = nil;

      $a = $opal.to_ary(sexp), _ = ($a[0] == null ? nil : $a[0]), array = ($a[1] == null ? nil : $a[1]), lasgn_or_array = ($a[2] == null ? nil : $a[2]), body = ($a[3] == null ? nil : $a[3]);
      e_dot_next = self.$s("call", self.$s("lvar", "__enumerator"), "next", self.$s("arglist"));
      if (lasgn_or_array['$[]'](0)['$==']("lasgn")) {
        assigns = self.$s("lasgn", lasgn_or_array['$[]'](1), e_dot_next)
      } else if (lasgn_or_array['$[]'](0)['$==']("array")) {
        assigns = self.$s("masgn", lasgn_or_array, e_dot_next)
        } else {
        self.$no("assignments in for s-exp except lasgn or array")
      };
      return ($a = ($b = self.$compile(self.$s("block", self.$s("lasgn", "__enumerator", self.$s("call", array, "each", self.$s("arglist"))), self.$s("rescue", self.$s("while", self.$s("true"), self.$s("block", assigns, ((($c = body) !== false && $c !== nil) ? $c : self.$s("nil")))), self.$s("resbody", self.$s("array", self.$s("const", "StopIteration")), nil))))).$reject, $a._p = (TMP_13 = function(bytecode){var self = TMP_13._s || this, $a, $b, $c;
if (bytecode == null) bytecode = nil;
      return ((($a = bytecode['$=='](["token", -1, -1])) !== false && $a !== nil) ? $a : ($b = (($c = bytecode['$[]'](0)['$==']("position")) ? bytecode['$[]'](2)['$=='](-1) : $c), $b !== false && $b !== nil ?bytecode['$[]'](3)['$=='](-1) : $b))}, TMP_13._s = self, TMP_13), $a).call($b);
    };

    return (def.$s = function(args) {
      var self = this;

      args = $slice.call(arguments, 0);
      $opal.defs(args, '$source', function() {
        var self = this;

        return [-1, -1];
      });
      return args;
    }, nil) && 's';
  })(self, null)
})(Opal);
/* Generated by Opal 0.7.0.dev */
(function($opal) {
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $gvars = $opal.gvars, $klass = $opal.klass, $hash2 = $opal.hash2, $range = $opal.range;
  if ($gvars.stdout == null) $gvars.stdout = nil;
  if ($gvars.stderr == null) $gvars.stderr = nil;

  $opal.add_stubs(['$==', '$>', '$size', '$write', '$join', '$map', '$+', '$end_with?', '$each', '$inspect', '$===', '$[]', '$clone', '$old_write', '$attr_reader', '$eval', '$raise', '$reverse_each', '$send', '$to_proc', '$singleton_class', '$name', '$reject', '$include?', '$object_id', '$push', '$[]=', '$last', '$result_is', '$pop_result', '$new', '$instance_variable_set', '$-', '$!', '$pop', '$do_call', '$map!', '$intern', '$has_key?', '$each_with_index', '$shift', '$call', '$instance_variable_get', '$lambda?', '$<', '$nil?', '$raise_exception', '$keys', '$>=', '$count', '$values', '$select', '$to_s', '$const_get', '$undefine_methods!', '$private', '$public_send', '$method', '$respond_to?', '$simulate_call_to', '$lambda', '$message', '$handle_exception', '$sprintf', '$reverse', '$class', '$backtrace']);
  $opal.cdecl($scope, 'UNNAMED_BLOCK', "__unnamed_block");
  if ($scope.RUBY_PLATFORM['$==']("opal")) {
    $opal.Object._proto.$gets = function() {
      var self = this;

      return nil;
    };
    $opal.Object._proto.$puts = function(args) {
      var $a, $b, TMP_1, self = this;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      args = $slice.call(arguments, 0);
      if (args.$size()['$>'](0)) {
        $gvars.stdout.$write(($a = ($b = args).$map, $a._p = (TMP_1 = function(arg){var self = TMP_1._s || this, $a, arg_to_s = nil;
if (arg == null) arg = nil;
        arg_to_s = "" + (arg);
          return arg_to_s['$+'](((function() {if ((($a = arg_to_s['$end_with?']("\n")) !== nil && (!$a._isBoolean || $a == true))) {
            return ""
            } else {
            return "\n"
          }; return nil; })()));}, TMP_1._s = self, TMP_1), $a).call($b).$join())
        } else {
        $gvars.stdout.$write("\n")
      };
      return nil;
    };
    $opal.Object._proto.$p = function(args) {
      var $a, $b, TMP_2, self = this, $case = nil;

      args = $slice.call(arguments, 0);
      ($a = ($b = args).$each, $a._p = (TMP_2 = function(arg){var self = TMP_2._s || this;
        if ($gvars.stdout == null) $gvars.stdout = nil;
if (arg == null) arg = nil;
      return $gvars.stdout.$write(arg.$inspect()['$+']("\n"))}, TMP_2._s = self, TMP_2), $a).call($b);
      return (function() {$case = args.$size();if ((0)['$===']($case)) {return nil}else if ((1)['$===']($case)) {return args['$[]'](0)}else {return args}})();
    };};
  $gvars.console_texts = [];
  $gvars.is_capturing_output = false;
  (function(self) {
    var $scope = self._scope, def = self._proto;

    self._proto.$old_write = self._proto.$write;
    return (self._proto.$write = function(args) {
      var $a, $b, TMP_3, self = this;
      if ($gvars.is_capturing_output == null) $gvars.is_capturing_output = nil;
      if ($gvars.console_texts == null) $gvars.console_texts = nil;

      args = $slice.call(arguments, 0);
      if ((($a = $gvars.is_capturing_output) !== nil && (!$a._isBoolean || $a == true))) {
        return $gvars.console_texts = $gvars.console_texts.$clone()['$+'](($a = ($b = args).$map, $a._p = (TMP_3 = function(arg){var self = TMP_3._s || this;
if (arg == null) arg = nil;
        return ["stdout", "" + (arg)]}, TMP_3._s = self, TMP_3), $a).call($b))
        } else {
        return ($a = self).$old_write.apply($a, [].concat(args))
      };
    }, nil) && 'write';
  })($gvars.stdout.$singleton_class());
  (function(self) {
    var $scope = self._scope, def = self._proto;

    self._proto.$old_write = self._proto.$write;
    return (self._proto.$write = function(args) {
      var $a, $b, TMP_4, self = this;
      if ($gvars.is_capturing_output == null) $gvars.is_capturing_output = nil;
      if ($gvars.console_texts == null) $gvars.console_texts = nil;

      args = $slice.call(arguments, 0);
      if ((($a = $gvars.is_capturing_output) !== nil && (!$a._isBoolean || $a == true))) {
        return $gvars.console_texts = $gvars.console_texts.$clone()['$+'](($a = ($b = args).$map, $a._p = (TMP_4 = function(arg){var self = TMP_4._s || this;
if (arg == null) arg = nil;
        return ["stderr", "" + (arg)]}, TMP_4._s = self, TMP_4), $a).call($b))
        } else {
        return ($a = self).$old_write.apply($a, [].concat(args))
      };
    }, nil) && 'write';
  })($gvars.stderr.$singleton_class());
  (function($base, $super) {
    function $String(){};
    var self = $String = $klass($base, $super, 'String', $String);

    var def = self._proto, $scope = self._scope;

    return (def.$append = function(args) {
      var $a, $b, TMP_5, self = this;

      args = $slice.call(arguments, 0);
      return self['$+'](($a = ($b = args).$map, $a._p = (TMP_5 = function(arg){var self = TMP_5._s || this;
if (arg == null) arg = nil;
      return "" + (arg)}, TMP_5._s = self, TMP_5), $a).call($b).$join());
    }, nil) && 'append'
  })(self, null);
  (function($base, $super) {
    function $ProgramTerminated(){};
    var self = $ProgramTerminated = $klass($base, $super, 'ProgramTerminated', $ProgramTerminated);

    var def = self._proto, $scope = self._scope;

    self.$attr_reader("cause");

    return (def.$initialize = function(cause) {
      var self = this;

      return self.cause = cause;
    }, nil) && 'initialize';
  })(self, $scope.RuntimeError);
  return (function($base, $super) {
    function $BytecodeInterpreter(){};
    var self = $BytecodeInterpreter = $klass($base, $super, 'BytecodeInterpreter', $BytecodeInterpreter);

    var def = self._proto, $scope = self._scope, TMP_29, TMP_31;

    def.methods_to_restore = def.partial_calls = def.vars_stack = def.num_partial_call_executing = def.accepting_input = def.result = def.method_stack = def.main = def.accepted_input = def.rescue_labels = nil;
    def.$initialize = function() {
      var $a, self = this;

      self.partial_calls = [];
      self.num_partial_call_executing = nil;
      self.result = [];
      self.vars_stack = [$hash2(["__method_name"], {"__method_name": [false, "in '<main>'"]})];
      self.main = (function() {if ((($a = ($scope.RUBY_PLATFORM['$==']("opal"))) !== nil && (!$a._isBoolean || $a == true))) {
        return Opal.top;
        } else {
        return $scope.TOPLEVEL_BINDING.$eval("self")
      }; return nil; })();
      self.accepting_input = false;
      self.accepted_input = nil;
      self.rescue_labels = [];
      self.method_stack = [["Runtime", "<main>", nil, nil, false]];
      self.methods_to_restore = $hash2([], {});
      $gvars.console_texts = [];
      try {
      return self.$raise("")
      } catch ($err) {if (true) {
        return nil
        }else { throw $err; }
      };
    };

    def['$undefine_methods!'] = function() {
      var $a, $b, TMP_6, self = this;

      return ($a = ($b = self.methods_to_restore).$reverse_each, $a._p = (TMP_6 = function(pair, method){var self = TMP_6._s || this, $a, $b, receiver = nil, method_name = nil;
if (pair == null) pair = nil;if (method == null) method = nil;
      $a = $opal.to_ary(pair), receiver = ($a[0] == null ? nil : $a[0]), method_name = ($a[1] == null ? nil : $a[1]);
        if (method !== false && method !== nil) {
          return ($a = ($b = receiver.$singleton_class()).$send, $a._p = method.$to_proc(), $a).call($b, "define_method", method.$name())
          } else {
          return receiver.$singleton_class().$send("remove_method", method_name)
        };}, TMP_6._s = self, TMP_6), $a).call($b);
    };

    def.$visible_state = function() {
      var $a, $b, TMP_7, $c, TMP_8, self = this, used_object_ids = nil;
      if ($gvars.console_texts == null) $gvars.console_texts = nil;

      used_object_ids = [];
      return $hash2(["partial_calls", "vars_stack", "output", "num_partial_call_executing", "accepting_input", "result"], {"partial_calls": ($a = ($b = self.partial_calls).$map, $a._p = (TMP_7 = function(call){var self = TMP_7._s || this;
if (call == null) call = nil;
      return call.$clone()}, TMP_7._s = self, TMP_7), $a).call($b), "vars_stack": ($a = ($c = self.vars_stack).$map, $a._p = (TMP_8 = function(vars){var self = TMP_8._s || this, $a, $b, TMP_9;
if (vars == null) vars = nil;
      return ($a = ($b = vars).$reject, $a._p = (TMP_9 = function(name, tuple){var self = TMP_9._s || this, $a;
if (name == null) name = nil;if (tuple == null) tuple = nil;
        if ((($a = used_object_ids['$include?'](tuple.$object_id())) !== nil && (!$a._isBoolean || $a == true))) {
            return true
            } else {
            used_object_ids.$push(tuple.$object_id());
            return false;
          }}, TMP_9._s = self, TMP_9), $a).call($b)}, TMP_8._s = self, TMP_8), $a).call($c), "output": $gvars.console_texts, "num_partial_call_executing": self.num_partial_call_executing, "accepting_input": self.accepting_input, "result": self.result});
    };

    def['$is_accepting_input?'] = function() {
      var self = this;

      return self.accepting_input;
    };

    def.$interpret = function(bytecode) {
      var $a, $b, TMP_10, $c, TMP_11, $d, $e, TMP_12, $f, TMP_13, $g, TMP_14, $h, TMP_15, $i, TMP_16, $j, TMP_17, $k, $l, TMP_18, TMP_19, $m, TMP_20, $n, TMP_21, $o, TMP_22, $p, $q, TMP_23, self = this, $case = nil, result = nil, call = nil, _ = nil, pop_next_method_too = nil, var_names = nil, splat_num = nil, block_num = nil, array = nil, old_array = nil, old = nil, new$ = nil, out = nil, min_num_args = nil, max_num_args = nil, receiver = nil, method_name = nil, block_arg = nil, args = nil, tricks = nil, num_expected = nil, message = nil, env = nil, num_args = nil, label = nil, stack_size1 = nil, stack_size2 = nil, pending_var_names = nil;
      if ($gvars["!"] == null) $gvars["!"] = nil;
      if ($gvars.bang == null) $gvars.bang = nil;

      return (function() {$case = bytecode['$[]'](0);if ("position"['$===']($case)) {self.method_stack.$last()['$[]='](0, bytecode['$[]'](1));
      self.method_stack.$last()['$[]='](2, bytecode['$[]'](2));
      self.method_stack.$last()['$[]='](3, bytecode['$[]'](3));
      return nil;}else if ("token"['$===']($case)) {self.method_stack.$last()['$[]='](2, bytecode['$[]'](1));
      self.method_stack.$last()['$[]='](3, bytecode['$[]'](2));
      return nil;}else if ("result"['$===']($case)) {self.$result_is(bytecode['$[]'](1));
      return nil;}else if ("result_nil"['$===']($case)) {self.$result_is(nil);
      return nil;}else if ("result_array"['$===']($case)) {self.$result_is([]);
      return nil;}else if ("discard"['$===']($case)) {self.$pop_result();
      return nil;}else if ("start_call"['$===']($case)) {self.partial_calls.$push([]);
      return nil;}else if ("top"['$===']($case)) {self.$result_is(self.main);
      return nil;}else if ("arg"['$===']($case)) {result = self.$pop_result();
      self.partial_calls.$last().$push(result);
      return nil;}else if ("make_proc"['$===']($case)) {result = ($a = ($b = $scope.Proc).$new, $a._p = (TMP_10 = function(args){var self = TMP_10._s || this;
args = $slice.call(arguments, 0);
      return ["RedirectMethod", bytecode['$[]'](1)]}, TMP_10._s = self, TMP_10), $a).call($b);
      result.$instance_variable_set("@env", ($a = ($c = self.vars_stack.$last()).$reject, $a._p = (TMP_11 = function(name, value){var self = TMP_11._s || this;
if (name == null) name = nil;if (value == null) value = nil;
      return name['$==']("__method_name")}, TMP_11._s = self, TMP_11), $a).call($c));
      result.$instance_variable_set("@defined_in", self.method_stack.$last());
      result.$instance_variable_set("@is_yield", false);
      self.$result_is(result);
      return nil;}else if ("pre_call"['$===']($case)) {self.num_partial_call_executing = self.partial_calls.$size()['$-'](1);
      if (self.partial_calls.$last()['$==']([self.main, "gets", nil])) {
        self.accepting_input = true};
      return nil;}else if ("call"['$===']($case)) {self.num_partial_call_executing = nil;
      call = self.partial_calls.$last();
      if ((($a = self.accepted_input['$=='](nil)['$!']()) !== nil && (!$a._isBoolean || $a == true))) {
        self.$result_is(self.accepted_input);
        self.accepted_input = nil;
        self.partial_calls.$pop();
        return nil;
        } else {
        result = ($a = self).$do_call.apply($a, [].concat(call));
        if ((($d = ($e = $scope.Array['$==='](result), $e !== false && $e !== nil ?result['$[]'](0)['$==']("RedirectMethod") : $e)) !== nil && (!$d._isBoolean || $d == true))) {
          return ["GOSUB", result['$[]'](1)]
        } else if ((($d = ($e = $scope.Array['$==='](result), $e !== false && $e !== nil ?result['$[]'](0)['$==']("RESCUE") : $e)) !== nil && (!$d._isBoolean || $d == true))) {
          self.$result_is(nil);
          self.partial_calls.$pop();
          return result;
          } else {
          self.$result_is(result);
          self.partial_calls.$pop();
          return nil;
        };
      };}else if ("return"['$===']($case)) {self.partial_calls.$pop();
      self.vars_stack.$pop();
      $d = $opal.to_ary(self.method_stack.$pop()), _ = ($d[0] == null ? nil : $d[0]), _ = ($d[1] == null ? nil : $d[1]), _ = ($d[2] == null ? nil : $d[2]), _ = ($d[3] == null ? nil : $d[3]), pop_next_method_too = ($d[4] == null ? nil : $d[4]);
      if (pop_next_method_too !== false && pop_next_method_too !== nil) {
        self.vars_stack.$pop();
        self.method_stack.$pop();};
      return ["RETURN"];}else if ("start_vars"['$===']($case)) {$d = $opal.to_ary(bytecode), _ = ($d[0] == null ? nil : $d[0]), var_names = $slice.call($d, 1);
      ($d = ($e = var_names)['$map!'], $d._p = (TMP_12 = function(var_name){var self = TMP_12._s || this;
if (var_name == null) var_name = nil;
      return var_name.$intern()}, TMP_12._s = self, TMP_12), $d).call($e);
      ($d = ($f = var_names).$each, $d._p = (TMP_13 = function(var_name){var self = TMP_13._s || this, $a;
        if (self.vars_stack == null) self.vars_stack = nil;
if (var_name == null) var_name = nil;
      if ((($a = self.vars_stack.$last()['$has_key?'](var_name)) !== nil && (!$a._isBoolean || $a == true))) {
          return self.vars_stack.$last()['$[]'](var_name)['$[]='](0, true)
          } else {
          return self.vars_stack.$last()['$[]='](var_name, [true])
        }}, TMP_13._s = self, TMP_13), $d).call($f);
      return nil;}else if ("to_var"['$===']($case)) {var_name = bytecode['$[]'](1).$intern();
      value = self.$pop_result();
      self.vars_stack.$last()['$[]'](var_name)['$[]='](0, false);
      self.vars_stack.$last()['$[]'](var_name)['$[]='](1, value);
      self.$result_is(value);
      return nil;}else if ("to_vars"['$===']($case)) {$d = $opal.to_ary(bytecode), _ = ($d[0] == null ? nil : $d[0]), splat_num = ($d[1] == null ? nil : $d[1]), block_num = ($d[2] == null ? nil : $d[2]), var_names = $slice.call($d, 3);
      ($d = ($g = var_names)['$map!'], $d._p = (TMP_14 = function(var_name){var self = TMP_14._s || this;
if (var_name == null) var_name = nil;
      return var_name.$intern()}, TMP_14._s = self, TMP_14), $d).call($g);
      array = self.$pop_result();
      old_array = array.$clone();
      ($d = ($h = var_names).$each_with_index, $d._p = (TMP_15 = function(var_name, i){var self = TMP_15._s || this;
        if (self.vars_stack == null) self.vars_stack = nil;
if (var_name == null) var_name = nil;if (i == null) i = nil;
      if (i['$=='](splat_num)) {
          value = array
        } else if (i['$=='](block_num)) {
          value = self.vars_stack.$last()['$[]']($scope.UNNAMED_BLOCK)['$[]'](1)
          } else {
          value = array.$shift()
        };
        self.vars_stack.$last()['$[]'](var_name)['$[]='](0, false);
        return self.vars_stack.$last()['$[]'](var_name)['$[]='](1, value);}, TMP_15._s = self, TMP_15), $d).call($h);
      if ((($d = self.vars_stack.$last()['$[]']($scope.UNNAMED_BLOCK)) !== nil && (!$d._isBoolean || $d == true))) {
        old = self.vars_stack.$last()['$[]']($scope.UNNAMED_BLOCK)['$[]'](1);
        new$ = ($d = ($i = $scope.Proc).$new, $d._p = (TMP_16 = function(args){var self = TMP_16._s || this, $a;
args = $slice.call(arguments, 0);
        return ($a = old).$call.apply($a, [].concat(args))}, TMP_16._s = self, TMP_16), $d).call($i);
        new$.$instance_variable_set("@env", old.$instance_variable_get("@env"));
        new$.$instance_variable_set("@defined_in", old.$instance_variable_get("@defined_in"));
        new$.$instance_variable_set("@is_yield", true);
        self.vars_stack.$last()['$[]']($scope.UNNAMED_BLOCK)['$[]='](1, new$);};
      self.$result_is(old_array);
      return nil;}else if ("from_var"['$===']($case)) {var_name = bytecode['$[]'](1).$intern();
      if ((($d = self.vars_stack.$last()['$has_key?'](var_name)) !== nil && (!$d._isBoolean || $d == true))) {
        out = self.vars_stack.$last()['$[]'](var_name)['$[]'](1);
        self.$result_is(out);
        } else {
        self.$raise("Looking up unset variable " + (var_name))
      };
      return nil;}else if ("make_symbol"['$===']($case)) {result = self.$pop_result().$intern();
      if ($scope.RUBY_PLATFORM['$==']("opal")) {
        result.is_symbol = true;};
      self.$result_is(result);
      return nil;}else if ("goto"['$===']($case)) {return ["GOTO", bytecode['$[]'](1)]}else if ("goto_if_not"['$===']($case)) {result = self.$pop_result();
      if ((($d = result['$!']()) !== nil && (!$d._isBoolean || $d == true))) {
        return ["GOTO", bytecode['$[]'](1)]
        } else {
        return nil
      };}else if ("args"['$===']($case)) {$d = $opal.to_ary(bytecode), _ = ($d[0] == null ? nil : $d[0]), min_num_args = ($d[1] == null ? nil : $d[1]), max_num_args = ($d[2] == null ? nil : $d[2]), var_names = $slice.call($d, 3);
      ($d = ($j = var_names)['$map!'], $d._p = (TMP_17 = function(var_name){var self = TMP_17._s || this;
if (var_name == null) var_name = nil;
      return var_name.$intern()}, TMP_17._s = self, TMP_17), $d).call($j);
      $d = $opal.to_ary(self.partial_calls.$last()), receiver = ($d[0] == null ? nil : $d[0]), method_name = ($d[1] == null ? nil : $d[1]), block_arg = ($d[2] == null ? nil : $d[2]), args = $slice.call($d, 3);
      self.$result_is(args);
      tricks = (($d = ($k = $scope.Proc['$==='](receiver), $k !== false && $k !== nil ?method_name['$==']("call") : $k), $d !== false && $d !== nil ?receiver['$lambda?']()['$=='](false) : $d));
      if (tricks !== false && tricks !== nil) {
        if ((($d = (($k = args.$size()['$=='](1)) ? $scope.Array['$==='](args['$[]'](0)) : $k)) !== nil && (!$d._isBoolean || $d == true))) {
          self.$pop_result();
          self.$result_is(args['$[]'](0));}
      } else if ((($d = ((($k = ((($l = min_num_args !== false && min_num_args !== nil) ? args.$size()['$<'](min_num_args) : $l))) !== false && $k !== nil) ? $k : ((($l = max_num_args !== false && max_num_args !== nil) ? args.$size()['$>'](max_num_args) : $l)))) !== nil && (!$d._isBoolean || $d == true))) {
        num_expected = (function() {if ((($d = max_num_args['$nil?']()) !== nil && (!$d._isBoolean || $d == true))) {
          return "" + (min_num_args) + "+"
        } else if (min_num_args['$=='](max_num_args)) {
          return min_num_args
          } else {
          return "" + (min_num_args) + ".." + (max_num_args)
        }; return nil; })();
        message = "wrong number of arguments (" + (args.$size()) + " for " + (num_expected) + ")";
        ($d = ($k = self).$raise_exception, $d._p = (TMP_18 = function(){var self = TMP_18._s || this;

        return self.$raise($scope.ArgumentError.$new(message))}, TMP_18._s = self, TMP_18), $d).call($k);};
      if ((($d = $scope.Proc['$==='](self.partial_calls.$last()['$[]'](0))) !== nil && (!$d._isBoolean || $d == true))) {
        env = self.partial_calls.$last()['$[]'](0).$instance_variable_get("@env");
        ($d = ($l = env.$keys()).$each, $d._p = (TMP_19 = function(var_name){var self = TMP_19._s || this, $a;
          if (self.vars_stack == null) self.vars_stack = nil;
if (var_name == null) var_name = nil;
        if ((($a = var_names['$include?'](var_name)['$!']()) !== nil && (!$a._isBoolean || $a == true))) {
            return self.vars_stack.$last()['$[]='](var_name, env['$[]'](var_name))
            } else {
            return nil
          }}, TMP_19._s = self, TMP_19), $d).call($l);};
      ($d = ($m = var_names).$each, $d._p = (TMP_20 = function(var_name){var self = TMP_20._s || this, $a;
        if (self.vars_stack == null) self.vars_stack = nil;
if (var_name == null) var_name = nil;
      if ((($a = self.vars_stack.$last()['$has_key?'](var_name)) !== nil && (!$a._isBoolean || $a == true))) {
          return nil
          } else {
          return self.vars_stack.$last()['$[]='](var_name, [true])
        }}, TMP_20._s = self, TMP_20), $d).call($m);
      self.vars_stack.$last()['$[]=']($scope.UNNAMED_BLOCK, [false, block_arg]);
      return nil;}else if ("goto_param_defaults"['$===']($case)) {num_args = self.partial_calls.$last().$size()['$-'](3);
      if ((1)['$+'](num_args)['$>='](bytecode.$size())) {
        label = bytecode.$last()
        } else {
        label = bytecode['$[]']((1)['$+']((num_args)))
      };
      return ["GOTO", label];}else if ("push_rescue"['$===']($case)) {stack_size1 = self.method_stack.$size();
      stack_size2 = ($d = ($n = self.method_stack).$count, $d._p = (TMP_21 = function(m){var self = TMP_21._s || this;
if (m == null) m = nil;
      return m['$[]'](4)['$!']()}, TMP_21._s = self, TMP_21), $d).call($n);
      pending_var_names = ($d = ($o = ($p = ($q = self.vars_stack.$last()).$select, $p._p = (TMP_23 = function(var_name, tuple){var self = TMP_23._s || this;
if (var_name == null) var_name = nil;if (tuple == null) tuple = nil;
      return tuple['$[]'](0)}, TMP_23._s = self, TMP_23), $p).call($q).$values()).$map, $d._p = (TMP_22 = function(tuple){var self = TMP_22._s || this;
if (tuple == null) tuple = nil;
      return tuple['$[]'](1)}, TMP_22._s = self, TMP_22), $d).call($o);
      self.rescue_labels.$push([bytecode['$[]'](1), stack_size1, stack_size2, self.partial_calls.$size(), pending_var_names]);
      return nil;}else if ("pop_rescue"['$===']($case)) {$d = $opal.to_ary(self.rescue_labels.$pop()), label = ($d[0] == null ? nil : $d[0]), _ = $slice.call($d, 1);
      if ((($d = label['$=='](bytecode['$[]'](1))['$!']()) !== nil && (!$d._isBoolean || $d == true))) {
        self.$raise("Expected to pop " + (bytecode['$[]'](1)) + " but was " + (label))};
      return nil;}else if ("to_gvar"['$===']($case)) {var_name = bytecode['$[]'](1).$intern();
      value = self.$pop_result();
      self.$eval("" + (var_name) + " = value");
      self.$result_is(value);
      return nil;}else if ("from_gvar"['$===']($case)) {var_name = bytecode['$[]'](1).$intern();
      if (var_name.$to_s()['$==']("$!")) {
        out = ((($d = $gvars["!"]) !== false && $d !== nil) ? $d : $gvars.bang)
        } else {
        out = self.$eval(var_name.$to_s())
      };
      self.$result_is(out);
      return nil;}else if ("const"['$===']($case)) {self.$result_is($scope.Module.$const_get(bytecode['$[]'](1).$intern()));
      return nil;}else if ("clear_dollar_bang"['$===']($case)) {$gvars.bang = nil;
      return nil;}else if ("done"['$===']($case)) {self['$undefine_methods!']();
      return nil;}else { return nil }})();
    };

    def.$set_input = function(text) {
      var $a, self = this;
      if ($gvars.console_texts == null) $gvars.console_texts = nil;

      self.accepted_input = text;
      self.accepting_input = false;
      if ((($a = false) !== nil && (!$a._isBoolean || $a == true))) {
        return $gvars.console_texts = $gvars.console_texts.$clone()['$+']([["stdin", text]])
        } else {
        return nil
      };
    };

    def.$get_stdout = function() {
      var $a, $b, TMP_24, $c, TMP_25, self = this, stdout_pairs = nil;
      if ($gvars.console_texts == null) $gvars.console_texts = nil;

      stdout_pairs = ($a = ($b = $gvars.console_texts).$select, $a._p = (TMP_24 = function(pair){var self = TMP_24._s || this;
if (pair == null) pair = nil;
      return pair['$[]'](0)['$==']("stdout")}, TMP_24._s = self, TMP_24), $a).call($b);
      return ($a = ($c = stdout_pairs).$map, $a._p = (TMP_25 = function(pair){var self = TMP_25._s || this;
if (pair == null) pair = nil;
      return pair['$[]'](1)}, TMP_25._s = self, TMP_25), $a).call($c).$join();
    };

    def.$get_stderr = function() {
      var $a, $b, TMP_26, $c, TMP_27, self = this, stderr_pairs = nil;
      if ($gvars.console_texts == null) $gvars.console_texts = nil;

      stderr_pairs = ($a = ($b = $gvars.console_texts).$select, $a._p = (TMP_26 = function(pair){var self = TMP_26._s || this;
if (pair == null) pair = nil;
      return pair['$[]'](0)['$==']("stderr")}, TMP_26._s = self, TMP_26), $a).call($b);
      return ($a = ($c = stderr_pairs).$map, $a._p = (TMP_27 = function(pair){var self = TMP_27._s || this;
if (pair == null) pair = nil;
      return pair['$[]'](1)}, TMP_27._s = self, TMP_27), $a).call($c).$join();
    };

    def.$get_stdout_and_stderr = function() {
      var $a, $b, TMP_28, self = this;
      if ($gvars.console_texts == null) $gvars.console_texts = nil;

      return ($a = ($b = $gvars.console_texts).$select, $a._p = (TMP_28 = function(pair){var self = TMP_28._s || this, $a;
if (pair == null) pair = nil;
      return ((($a = pair['$[]'](0)['$==']("stdout")) !== false && $a !== nil) ? $a : pair['$[]'](0)['$==']("stderr"))}, TMP_28._s = self, TMP_28), $a).call($b);
    };

    self.$private();

    def.$result_is = function(new_result) {
      var self = this;

      if ($scope.RUBY_PLATFORM['$==']("opal")) {
        if (typeof(new_result) === 'number') {
        new_result = new Number(new_result);
      } else if (typeof(new_result) === 'string') {
        new_result = new String(new_result);
      }};
      self.result.$push(new_result);
      if (self.result.$size()['$>'](1)) {
        return self.$raise("Result stack has too many items: " + (self.result))
        } else {
        return nil
      };
    };

    def.$simulate_call_to = TMP_29 = function(receiver, new_method_name, args) {
      var $a, self = this, $iter = TMP_29._p, proc_ = $iter || nil, entry = nil;

      args = $slice.call(arguments, 2);
      TMP_29._p = null;
      entry = self.method_stack.$pop();
      self.method_stack.$push([entry['$[]'](0), new_method_name, nil, nil, false]);
      self.partial_calls.$pop();
      self.partial_calls.$push([receiver, new_method_name, proc_].concat(args));
      return ($a = receiver).$public_send.apply($a, [new_method_name].concat(args));
    };

    def.$do_call = function(receiver, method_name, proc_, args) {
      var $a, $b, $c, $d, $e, $f, $g, $h, TMP_30, $i, $j, $k, $l, self = this, path = nil, _ = nil, line_num = nil, old_method = nil, key = nil, result = nil, new_method_name = nil, $case = nil, is_yield = nil, method = nil, new$ = nil, e = nil;

      args = $slice.call(arguments, 3);
      if ((($a = ($scope.Symbol['$==='](method_name))['$!']()) !== nil && (!$a._isBoolean || $a == true))) {
        self.$raise("Expected symbol for method_name")};
      $a = $opal.to_ary(self.method_stack.$last()), path = ($a[0] == null ? nil : $a[0]), _ = ($a[1] == null ? nil : $a[1]), line_num = ($a[2] == null ? nil : $a[2]);
      self.method_stack.$push([path, method_name, line_num, nil, false]);
      self.vars_stack.$push($hash2(["__method_name"], {"__method_name": [false, "in '" + (method_name) + "'"]}));
      try {
      if (method_name['$==']("define_method")) {
          try {
          old_method = receiver.$method(args['$[]'](0))
          } catch ($err) {if ($opal.$rescue($err, [$scope.NameError])) {
            old_method = nil
            }else { throw $err; }
          };
          key = [receiver, args['$[]'](0)];
          if ((($a = self.methods_to_restore['$has_key?'](key)) !== nil && (!$a._isBoolean || $a == true))) {
            } else {
            self.methods_to_restore['$[]='](key, old_method)
          };};
        result = (function() {if ((($a = ($b = ($c = receiver['$respond_to?'](method_name), $c !== false && $c !== nil ?proc_ : $c), $b !== false && $b !== nil ?["collect", "each", "each_index", "map", "reject", "select"]['$include?'](method_name.$to_s()) : $b)) !== nil && (!$a._isBoolean || $a == true))) {
          new_method_name = (function() {$case = method_name;if ("collect"['$===']($case)) {return "__map"}else if ("each"['$===']($case)) {return "__each"}else if ("each_index"['$===']($case)) {return "__each_index"}else if ("map"['$===']($case)) {return "__map"}else if ("reject"['$===']($case)) {return "__reject"}else if ("select"['$===']($case)) {return "__select"}else { return nil }})();
          return ($a = ($b = self).$simulate_call_to, $a._p = proc_.$to_proc(), $a).call($b, self.main, new_method_name, self.partial_calls.$last()['$[]'](0));
        } else if ((($a = ($c = ($d = $scope.Array['$==='](receiver), $d !== false && $d !== nil ?proc_ : $d), $c !== false && $c !== nil ?["keep_if", "map!", "select!"]['$include?'](method_name.$to_s()) : $c)) !== nil && (!$a._isBoolean || $a == true))) {
          new_method_name = (function() {$case = method_name;if ("keep_if"['$===']($case)) {return "__array_keep_if"}else if ("map!"['$===']($case)) {return "__array_map!"}else if ("select!"['$===']($case)) {return "__array_select!"}else { return nil }})();
          return ($a = ($c = self).$simulate_call_to, $a._p = proc_.$to_proc(), $a).call($c, self.main, new_method_name, self.partial_calls.$last()['$[]'](0));
        } else if (method_name['$==']("define_method")) {
          ($a = ($d = receiver.$singleton_class()).$send, $a._p = proc_.$to_proc(), $a).apply($d, ["define_method"].concat(args));
          return result = nil;
        } else if (method_name['$==']("send")) {
          new_method_name = args.$shift();
          return result = ($a = ($e = self).$simulate_call_to, $a._p = proc_.$to_proc(), $a).apply($e, [receiver, new_method_name].concat(args));
        } else if ((($a = ($f = $scope.Proc['$==='](receiver), $f !== false && $f !== nil ?method_name['$==']("call") : $f)) !== nil && (!$a._isBoolean || $a == true))) {
          is_yield = receiver.$instance_variable_get("@is_yield");
          if (is_yield !== false && is_yield !== nil) {
            self.method_stack.$pop();
            self.vars_stack.$pop();};
          $a = $opal.to_ary(receiver.$instance_variable_get("@defined_in")), path = ($a[0] == null ? nil : $a[0]), method = ($a[1] == null ? nil : $a[1]);
          self.method_stack.$push([path, "block in " + (method), nil, nil, is_yield['$!']()]);
          self.vars_stack.$push($hash2(["__method_name"], {"__method_name": (function() {if ((($a = (method['$==']("<main>"))) !== nil && (!$a._isBoolean || $a == true))) {
            return [false, "in block"]
            } else {
            return [false, "in block in '" + (method) + "'"]
          }; return nil; })()}));
          return result = ($a = ($f = receiver).$public_send, $a._p = proc_.$to_proc(), $a).apply($f, [method_name].concat(args));
        } else if ((($a = ($g = $scope.Fixnum['$==='](receiver), $g !== false && $g !== nil ?method_name['$==']("times") : $g)) !== nil && (!$a._isBoolean || $a == true))) {
          return ($a = ($g = self).$simulate_call_to, $a._p = proc_.$to_proc(), $a).call($g, self.main, "__fixnum_times", self.partial_calls.$last()['$[]'](0))
        } else if ((($a = (($h = receiver['$=='](self.main)) ? method_name['$==']("lambda") : $h)) !== nil && (!$a._isBoolean || $a == true))) {
          new$ = ($a = ($h = self).$lambda, $a._p = (TMP_30 = function(args){var self = TMP_30._s || this, $a;
args = $slice.call(arguments, 0);
          return ($a = proc_).$call.apply($a, [].concat(args))}, TMP_30._s = self, TMP_30), $a).call($h);
          new$.$instance_variable_set("@env", proc_.$instance_variable_get("@env"));
          new$.$instance_variable_set("@defined_in", proc_.$instance_variable_get("@defined_in"));
          new$.$instance_variable_set("@is_yield", proc_.$instance_variable_get("@is_yield"));
          return result = ($a = ($i = receiver).$send, $a._p = new$.$to_proc(), $a).apply($i, [method_name].concat(args));
        } else if (receiver['$=='](self.main)) {
          try {
          $gvars.is_capturing_output = true;
            result = ($a = ($j = self.main).$send, $a._p = proc_.$to_proc(), $a).apply($j, [method_name].concat(args));
            $gvars.is_capturing_output = false;
            return result;
          } catch ($err) {if ($opal.$rescue($err, [$scope.NoMethodError])) {e = $err;
            if ((($a = (($k = args.$size()['$=='](0)) ? e.$message()['$==']("undefined method `" + (method_name) + "' for main") : $k)) !== nil && (!$a._isBoolean || $a == true))) {
              return self.$raise($scope.NameError.$new("undefined local variable or method "['$+']("`" + (method_name) + "' for main:Object")))
              } else {
              return self.$raise(e)
            }
            }else { throw $err; }
          }
          } else {
          $gvars.is_capturing_output = true;
          result = ($a = ($k = receiver).$public_send, $a._p = proc_.$to_proc(), $a).apply($k, [method_name].concat(args));
          $gvars.is_capturing_output = false;
          return result;
        }; return nil; })();
        if ((($a = ($l = $scope.Array['$==='](result), $l !== false && $l !== nil ?result['$[]'](0)['$==']("RedirectMethod") : $l)) !== nil && (!$a._isBoolean || $a == true))) {
          } else {
          self.method_stack.$pop();
          self.vars_stack.$pop();
        };
        return result;
      } catch ($err) {if ($opal.$rescue($err, [$scope.Exception])) {e = $err;
        $gvars.is_capturing_output = false;
        return self.$handle_exception(e);
        }else { throw $err; }
      };
    };

    def.$raise_exception = TMP_31 = function() {
      var $a, self = this, $iter = TMP_31._p, block = $iter || nil, e = nil;

      TMP_31._p = null;
      try {
      return $a = $opal.$yieldX(block, []), $a === $breaker ? $a : $a
      } catch ($err) {if (true) {e = $err;
        return self.$handle_exception(e)
        }else { throw $err; }
      };
    };

    def.$handle_exception = function(e) {
      var $a, $b, TMP_32, $c, TMP_33, $d, TMP_34, self = this, label = nil, target_stack_size1 = nil, target_stack_size2 = nil, partial_calls_size = nil, pending_var_names = nil, text = nil;
      if ($gvars["!"] == null) $gvars["!"] = nil;
      if ($gvars.console_texts == null) $gvars.console_texts = nil;

      e.$instance_variable_set("@backtrace", ($a = ($b = self.method_stack['$[]']($range(0, -1, true)).$reverse()).$map, $a._p = (TMP_32 = function(entry){var self = TMP_32._s || this;
if (entry == null) entry = nil;
      return self.$sprintf("%s:%s:in `%s'", entry['$[]'](0), entry['$[]'](2), entry['$[]'](1))}, TMP_32._s = self, TMP_32), $a).call($b));
      $opal.defs(e, '$backtrace', function() {
        var self = this;
        if (self.backtrace == null) self.backtrace = nil;

        return self.backtrace;
      });
      if (self.rescue_labels.$size()['$>'](0)) {
        $a = $opal.to_ary(self.rescue_labels.$pop()), label = ($a[0] == null ? nil : $a[0]), target_stack_size1 = ($a[1] == null ? nil : $a[1]), target_stack_size2 = ($a[2] == null ? nil : $a[2]), partial_calls_size = ($a[3] == null ? nil : $a[3]), pending_var_names = ($a[4] == null ? nil : $a[4]);
        while (self.method_stack.$size()['$>'](target_stack_size1)) {
        self.method_stack.$pop();
        self.vars_stack.$pop();};
        while (self.partial_calls.$size()['$>'](partial_calls_size['$+'](1))) {
        self.partial_calls.$pop()};
        ($a = ($c = self.vars_stack.$last()).$each, $a._p = (TMP_33 = function(var_name, tuple){var self = TMP_33._s || this, $a;
if (var_name == null) var_name = nil;if (tuple == null) tuple = nil;
        if ((($a = pending_var_names['$include?'](var_name)['$!']()) !== nil && (!$a._isBoolean || $a == true))) {
            return tuple['$[]='](0, false)
            } else {
            return nil
          }}, TMP_33._s = self, TMP_33), $a).call($c);
        $gvars.bang = $gvars["!"];
        return ["RESCUE", label, target_stack_size2];
        } else {
        text = ((((("") + (e.$class())) + ": ") + (e.$message())) + "\n")['$+'](($a = ($d = e.$backtrace()).$map, $a._p = (TMP_34 = function(entry){var self = TMP_34._s || this;
if (entry == null) entry = nil;
        return "  " + (entry)}, TMP_34._s = self, TMP_34), $a).call($d).$join("\n"));
        $gvars.console_texts = $gvars.console_texts.$clone()['$+']([["stderr", text]]);
        return self.$raise($scope.ProgramTerminated.$new(e));
      };
    };

    def.$pop_result = function() {
      var self = this;

      if (self.result['$==']([])) {
        self.$raise("Empty result stack")};
      return self.result.$pop();
    };

    return ($opal.defs(self, '$RUNTIME_PRELUDE', function() {
      var self = this;

      return "def __each __input\n  __enumerator = __input.each\n  begin\n    while true\n      yield __enumerator.next\n    end\n  rescue StopIteration\n  end\n  __input\nend\ndef __each_index __input\n  __enumerator = __input.each_index\n  begin\n    while true\n      yield __enumerator.next\n    end\n  rescue StopIteration\n  end\n  __input\nend\ndef __array_keep_if array\n  i = 0\n  n = array.size\n  while i < n\n    if !(yield array[i])\n      array.slice! i\n      i -= 1\n      n -= 1\n    end\n    i += 1\n  end\n  array\nend\ndef __map __input\n  __enumerator = __input.each\n  __output = []\n  begin\n    while true\n      __output.push yield __enumerator.next\n    end\n  rescue StopIteration\n  end\n  __output\nend\ndef __array_map! array\n  i = 0\n  n = array.size\n  while i < n\n    array[i] = yield array[i]\n    i += 1\n  end\n  array\nend\ndef __reject __input\n  __enumerator = __input.each\n  __output = []\n  begin\n    while true\n      __element = __enumerator.next\n      __output.push(__element) unless yield(__element)\n    end\n  rescue StopIteration\n  end\n  __output\nend\ndef __select __input\n  __enumerator = __input.each\n  __output = []\n  begin\n    while true\n      __element = __enumerator.next\n      __output.push(__element) if yield(__element)\n    end\n  rescue StopIteration\n  end\n  __output\nend\ndef __array_select! array\n  i = 0\n  n = array.size\n  changed = false\n  while i < n\n    if !(yield array[i])\n      array.slice! i\n      i -= 1\n      n -= 1\n      changed = true\n    end\n    i += 1\n  end\n  changed ? array : nil\nend\ndef __fixnum_times num\n  i = 0\n  while i < num\n    yield i\n    i += 1\n  end\n  num\nend\ndef assert_equal a, b\n  if b != a\n    raise \"Expected \#{a.inspect} but got \#{b.inspect}\"\n  end\nend\ndef __run_test test_name\n  begin\n    send test_name\n    puts \"\#{test_name} PASSED\"\n  rescue RuntimeError => e\n    $stderr.write \"\#{test_name} FAILED\\n\"\n    $stderr.write \"\#{e}\\n\"\n    e.backtrace[0...-2].each do |line|\n      $stderr.puts \"  \#{line}\\n\"\n    end\n  end\nend\n";
    }), nil) && 'RUNTIME_PRELUDE';
  })(self, null);
})(Opal);
/* Generated by Opal 0.7.0.dev */
(function($opal) {
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $klass = $opal.klass, $hash2 = $opal.hash2, $range = $opal.range;

  $opal.add_stubs(['$+', '$label_to_counter', '$==', '$>=', '$size', '$[]', '$-', '$===', '$!', '$raise', '$>', '$pop', '$push', '$private', '$each_with_index', '$[]=']);
  return (function($base, $super) {
    function $BytecodeSpool(){};
    var self = $BytecodeSpool = $klass($base, $super, 'BytecodeSpool', $BytecodeSpool);

    var def = self._proto, $scope = self._scope;

    def.counter = def.breakpoint = def.num_steps_queued = def.is_done = def.bytecodes = def.last_yourcode_position = def.label_to_counter = def.counter_stack = nil;
    def.$initialize = function(bytecodes) {
      var self = this;

      self.bytecodes = bytecodes['$+']([["done"]]);
      self.counter = 0;
      self.label_to_counter = self.$label_to_counter(bytecodes);
      self.breakpoint = "NEXT_POSITION";
      self.num_steps_queued = 0;
      self.is_done = false;
      self.counter_stack = [];
      return self.last_yourcode_position = [];
    };

    def.$counter = function() {
      var self = this;

      return self.counter;
    };

    def.$visible_state = function() {
      var self = this;

      return $hash2(["breakpoint", "num_steps_queued", "is_done"], {"breakpoint": self.breakpoint, "num_steps_queued": self.num_steps_queued, "is_done": self.is_done});
    };

    def['$is_done?'] = function() {
      var self = this;

      return self.is_done;
    };

    def.$queue_run_until = function(breakpoint) {
      var self = this;

      if (self.breakpoint['$=='](breakpoint)) {
        return self.num_steps_queued = self.num_steps_queued['$+'](1)
        } else {
        self.breakpoint = breakpoint;
        return self.num_steps_queued = 1;
      };
    };

    def.$get_next_bytecode = function() {
      var $a, $b, self = this, bytecode = nil, $case = nil, line0 = nil, col0 = nil, line1 = nil, col1 = nil;

      if ((($a = self.is_done) !== nil && (!$a._isBoolean || $a == true))) {
        return nil
      } else if (self.counter['$>='](self.bytecodes.$size())) {
        return nil
      } else if (self.num_steps_queued['$=='](0)) {
        return nil
        } else {
        bytecode = self.bytecodes['$[]'](self.counter);
        if (self.breakpoint['$==']("NEXT_BYTECODE")) {
          self.num_steps_queued = self.num_steps_queued['$-'](1)};
        $case = bytecode['$[]'](0);if ("position"['$===']($case)) {if (bytecode['$[]'](1)['$==']("YourCode")) {
          $a = $opal.to_ary(self.last_yourcode_position['$[]']($range(2, 3, false))), line0 = ($a[0] == null ? nil : $a[0]), col0 = ($a[1] == null ? nil : $a[1]);
          $a = $opal.to_ary([bytecode['$[]'](2), bytecode['$[]'](3)]), line1 = ($a[0] == null ? nil : $a[0]), col1 = ($a[1] == null ? nil : $a[1]);
          if (self.breakpoint['$==']("NEXT_POSITION")) {
            self.num_steps_queued = self.num_steps_queued['$-'](1)
          } else if ((($a = (($b = self.breakpoint['$==']("NEXT_LINE")) ? line1['$=='](line0)['$!']() : $b)) !== nil && (!$a._isBoolean || $a == true))) {
            self.num_steps_queued = self.num_steps_queued['$-'](1)};
          self.last_yourcode_position = bytecode;}}else if ("done"['$===']($case)) {self.num_steps_queued = 0;
        self.is_done = true;};
        self.counter = self.counter['$+'](1);
        return bytecode;
      };
    };

    def.$do_command = function(command, args) {
      var $a, self = this, $case = nil, label = nil, stack_size = nil;

      args = $slice.call(arguments, 1);
      return (function() {$case = command;if ("GOTO"['$===']($case)) {label = args['$[]'](0);
      return ((($a = self.counter = self.label_to_counter['$[]'](label)) !== false && $a !== nil) ? $a : self.$raise("Can't find label " + (label)));}else if ("RESCUE"['$===']($case)) {$a = [args['$[]'](0), args['$[]'](1)['$-'](1)], label = $a[0], stack_size = $a[1];
      while (self.counter_stack.$size()['$>'](stack_size)) {
      self.counter_stack.$pop()};
      return ((($a = self.counter = self.label_to_counter['$[]'](label)) !== false && $a !== nil) ? $a : self.$raise("Can't find label " + (label)));}else if ("GOSUB"['$===']($case)) {label = args['$[]'](0);
      self.counter_stack.$push(self.counter);
      return ((($a = self.counter = self.label_to_counter['$[]'](label)) !== false && $a !== nil) ? $a : self.$raise("Can't find label " + (label)));}else if ("RETURN"['$===']($case)) {return self.counter = self.counter_stack.$pop()}else { return nil }})();
    };

    def.$terminate_early = function() {
      var self = this;

      self.is_done = true;
      return self.num_steps_queued = 0;
    };

    def.$stop_early = function() {
      var self = this;

      return self.num_steps_queued = 0;
    };

    self.$private();

    return (def.$label_to_counter = function(bytecodes) {
      var $a, $b, TMP_1, self = this, hash = nil;

      hash = $hash2([], {});
      ($a = ($b = bytecodes).$each_with_index, $a._p = (TMP_1 = function(bytecode, counter){var self = TMP_1._s || this, label_name = nil;
if (bytecode == null) bytecode = nil;if (counter == null) counter = nil;
      if (bytecode['$[]'](0)['$==']("label")) {
          label_name = bytecode['$[]'](1);
          return hash['$[]='](label_name, counter);
          } else {
          return nil
        }}, TMP_1._s = self, TMP_1), $a).call($b);
      return hash;
    }, nil) && 'label_to_counter';
  })(self, null)
})(Opal);
/* Generated by Opal 0.7.0.dev */
(function($opal) {
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $klass = $opal.klass, $hash2 = $opal.hash2, $gvars = $opal.gvars;
  if ($gvars["0"] == null) $gvars["0"] = nil;

  $opal.add_stubs(['$new', '$instance_variable_set', '$push_scope', '$parser=', '$next_token', '$==', '$matched', '$scanner', '$[]', '$clone', '$[]=', '$+', '$length', '$nil?', '$send', '$p', '$build_start_pos_to_end_pos', '$build_line_start_pos_to_end_pos']);
  (function($base, $super) {
    function $Lexer(){};
    var self = $Lexer = $klass($base, $super, 'Lexer', $Lexer);

    var def = self._proto, $scope = self._scope;

    def.$build_start_pos_to_end_pos = function(code) {
      var $a, $b, $c, self = this, start_pos_to_end_pos = nil, lexer = nil, parser = nil, token_symbol = nil, value = nil, excerpt = nil, start_pos = nil, end_pos = nil;

      start_pos_to_end_pos = $hash2([], {});
      lexer = ($scope.Opal)._scope.Lexer.$new(code, "(eval)");
      parser = ($scope.Opal)._scope.Parser.$new();
      parser.$instance_variable_set("@lexer", lexer);
      parser.$instance_variable_set("@file", "(eval)");
      parser.$instance_variable_set("@scopes", []);
      parser.$push_scope("block");
      lexer['$parser='](parser);
      while ((($b = true) !== nil && (!$b._isBoolean || $b == true))) {
      $b = $opal.to_ary(parser.$next_token()), token_symbol = ($b[0] == null ? nil : $b[0]), value = ($b[1] == null ? nil : $b[1]);
      if (token_symbol['$=='](false)) {
        break;
      } else if ((($b = ((($c = token_symbol['$==']("tINTEGER")) !== false && $c !== nil) ? $c : token_symbol['$==']("tFLOAT"))) !== nil && (!$b._isBoolean || $b == true))) {
        excerpt = lexer.$scanner().$matched()
        } else {
        excerpt = value['$[]'](0)
      };
      start_pos = value['$[]'](1);
      end_pos = value['$[]'](1).$clone();
      ($b = 1, $c = end_pos, $c['$[]=']($b, $c['$[]']($b)['$+'](excerpt.$length())));
      start_pos_to_end_pos['$[]='](start_pos, end_pos);};
      return start_pos_to_end_pos;
    };

    return (def.$build_line_start_pos_to_end_pos = function(code) {
      var $a, $b, $c, self = this, line_start_pos_to_end_pos = nil, lexer = nil, parser = nil, last_start_pos = nil, last_end_pos = nil, directly_after_do = nil, token_symbol = nil, value = nil, excerpt = nil, end_pos = nil;

      line_start_pos_to_end_pos = $hash2([], {});
      lexer = ($scope.Opal)._scope.Lexer.$new(code, "(eval)");
      parser = ($scope.Opal)._scope.Parser.$new();
      parser.$instance_variable_set("@lexer", lexer);
      parser.$instance_variable_set("@file", "(eval)");
      parser.$instance_variable_set("@scopes", []);
      parser.$push_scope("block");
      lexer['$parser='](parser);
      last_start_pos = nil;
      last_end_pos = nil;
      directly_after_do = false;
      while ((($b = true) !== nil && (!$b._isBoolean || $b == true))) {
      $b = $opal.to_ary(parser.$next_token()), token_symbol = ($b[0] == null ? nil : $b[0]), value = ($b[1] == null ? nil : $b[1]);
      if (token_symbol['$=='](false)) {
        if ((($b = (($c = last_start_pos !== false && last_start_pos !== nil) ? last_end_pos : $c)) !== nil && (!$b._isBoolean || $b == true))) {
          line_start_pos_to_end_pos['$[]='](last_start_pos, last_end_pos);
          last_start_pos = nil;
          last_end_pos = nil;};
        break;;
      } else if ((($b = ((($c = token_symbol['$==']("kDO")) !== false && $c !== nil) ? $c : token_symbol['$==']("tLCURLY"))) !== nil && (!$b._isBoolean || $b == true))) {
        if ((($b = (($c = last_start_pos !== false && last_start_pos !== nil) ? last_end_pos : $c)) !== nil && (!$b._isBoolean || $b == true))) {
          line_start_pos_to_end_pos['$[]='](last_start_pos, last_end_pos);
          last_start_pos = nil;
          last_end_pos = nil;};
        directly_after_do = true;
        continue;;
      } else if ((($b = (($c = directly_after_do !== false && directly_after_do !== nil) ? token_symbol['$==']("tPIPE") : $c)) !== nil && (!$b._isBoolean || $b == true))) {
        parser.$next_token();
        parser.$next_token();
        continue;;
        directly_after_do = false;
      } else if ((($b = ((($c = token_symbol['$==']("tINTEGER")) !== false && $c !== nil) ? $c : token_symbol['$==']("tFLOAT"))) !== nil && (!$b._isBoolean || $b == true))) {
        excerpt = lexer.$scanner().$matched()
      } else if ((($b = ((($c = token_symbol['$==']("tNL")) !== false && $c !== nil) ? $c : token_symbol['$==']("tSEMI"))) !== nil && (!$b._isBoolean || $b == true))) {
        if ((($b = (($c = last_start_pos !== false && last_start_pos !== nil) ? last_end_pos : $c)) !== nil && (!$b._isBoolean || $b == true))) {
          line_start_pos_to_end_pos['$[]='](last_start_pos, last_end_pos);
          last_start_pos = nil;
          last_end_pos = nil;};
        continue;;
        } else {
        excerpt = value['$[]'](0)
      };
      directly_after_do = false;
      if ((($b = last_start_pos['$nil?']()) !== nil && (!$b._isBoolean || $b == true))) {
        last_start_pos = value['$[]'](1)};
      end_pos = value['$[]'](1).$clone();
      ($b = 1, $c = end_pos, $c['$[]=']($b, $c['$[]']($b)['$+'](excerpt.$length())));
      last_end_pos = end_pos;};
      return line_start_pos_to_end_pos;
    }, nil) && 'build_line_start_pos_to_end_pos';
  })(self, null);
  if ("lexer"['$==']($gvars["0"])) {
    self.$send("require", "opal");
    self.$p($scope.Lexer.$new().$build_start_pos_to_end_pos("puts 3\nputs 4"));
    self.$p($scope.Lexer.$new().$build_line_start_pos_to_end_pos("[1, 2].each do |x|\n  p x\n  p x\nend"));
    return self.$p($scope.Lexer.$new().$build_line_start_pos_to_end_pos("{} & a.map { |x| x * 2 }"));
    } else {
    return nil
  };
})(Opal);
